# Ответы на вопросы из части 2 WB Tech: level №1

## 1. Какой самый эффективный способ конкатенации строк?
Так как строки представляют собой неизменяемый слайс байтов, при конкатенации двух строк происходит выделение новой памяти. Это может негативно сказаться на потреблении памяти, если нужно соединить много строк. Поэтому в таких случаях следует использовать `strings.Builder`
## 2. Что такое интерфейсы, как они применяются в Go?
Интерфейсы представляют абстракцию поведения других типов. Интерфейсы позволяют определять функции, которые не привязаны к конкретной реализации. То есть интерфейсы определяют некоторый функционал, но не реализуют его.
  
  Существует несколько причин использования интерфейсрв в Go:
  1. Интерфейсы помогают уменьшить дублирование, то есть количество шаблонного кода.
  2. Они облегчают использование в модульных тестах заглушек вместо реальных объектов.
  3. Будучи архитектурным инструментом, интерфейсы помогают отвязывать части вашей кодовой базы.
## 3. Чем отличаются RWMutex от Mutex?
Главным отличием RWMutex от Mutex является методы `Rlock()` и `RUnlock()`. RWMutex нужен, когда у нас есть объект, который нельзя параллельно писать, но можно параллельно читать. Например, стандартный тип map.
## 4. Чем отличаются буферизированные и не буферизированные каналы?
Первое отличие буферизированных каналов от небуферизированных - это синтаксис.
```
channel := make(chan int) // небуферезированный канал

buffChannel := make(chan int, 5) // буфферезированный канал
```
Буферизированные каналы сохраняют получаемые данные в виде кольцевой очереди
Буферезированный канал будет наполняться до тех пор, пока его буффер не будет заполнен, в случае заполнения горутина блокируется.
## 5. Какой размер у структуры struct{}{}?
Размер `struct{}{}` - 0. 
## 6. Есть ли в Go перегрузка методов или операторов?
В языке Go нет перегрузки методов. Перегрузкой метода назвают одноименные функции реализация которых зависит от количества аргументов, которые туда передают.
## 7. В какой последовательности будут выведены элементы map[int]int?
Невозможно точно сказать в какой последовательности будут выведены элементы типа map.
## 8. В чем разница make и new?
Основное различие между new и make состоит в том, что переменные, созданные с помощью make, правильно инициализируются, а не только обнуляется выделенная для них память. Кроме того, make можно применять только к хеш-таблицам, каналам и срезам, и эта функция не возвращает адрес памяти, то есть make не возвращает указатель.
## 9.Сколько существует способов задать переменную типа slice или map?
Существует несколько способов
```go
m := make(map[int]bool, 0) // 1 способ
var m map[int]bool // 2 способ
var m = map[int]bool{} // 3 способ
```
## 10. Что выведет данная программа и почему?
```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
Программа выведет:
```
1
1
```
Это происходит потому, что в функции update изменяется копия указателя p, а не само значение, на которое он указывает. Когда мы передаем p в функцию update, создается копия указателя p, и изменения внутри функции update не влияют на оригинальный указатель p в функции main.

## 11. Что выведет данная программа и почему?
```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
Данная функция накопит в wg.Add 5 ожидаемых горутин, но в анонимную функцию передается копия wg, а не указатель, таким образом внутри функции значение главной переменной wg никак не меняется, как итог, функция wg.Wait не получит желаемый результат 0 и произойдет deadlock.

## 12. Что выведет данная программа и почему?
```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
Данная программа выведет 0, так как в локальной области видимости пересоздается переменная с тем же именем n и дпльнейшая работа происходит с ней, но при использование функции `fmt.Println(n)` программа видет только переменную из области видимости main.

## 13. Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
Вывод программы:
```
[100 2 3 4 5]
```
Это происходит потому, что в функции someAction мы изменяем значение по индексу 0 в срезе v, который на самом деле указывает на тот же участок памяти, что и срез a в функции main. Однако, когда мы добавляем элемент в срез v с помощью append, создается новый срез, который не связан с оригинальным срезом a. Поэтому изменения в срезе v не отражаются на оригинальном срезе a.
## 14. Что выведет данная программа и почему?
```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
Данная программа выведет два разных массива: `[b b a]` и `[a a]`, так как после операции append создается новый слайс, дальнейшая локальная работа происходит именно с ним. Исходный же слайс остется неизменным так как к нему нету обращений, опять же операции в анонимной функции представлены для локального и вновь созданного слайса




